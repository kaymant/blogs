[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "blogs",
    "section": "",
    "text": "Post With Code\n\n\n\nnews\n\ncode\n\nanalysis\n\n\n\n\n\n\n\n\n\nJan 26, 2026\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\n76x Faster: Benchmarking Matrix Multiplication in C\n\n\n\nC\n\nHPC\n\nLinear Algebra\n\nOptimization\n\n\n\nOptimizing Matrix Multiplication from naive loops to Tiled AVX2 + OpenMP.\n\n\n\n\n\nJan 26, 2026\n\n\nAnant Kumar\n\n\n\n\n\n\n\n\n\n\n\n\nVisualizing Functions with Contour Plots\n\n\n\nMathematics\n\nPython\n\nVisualization\n\n\n\nA guide to visualizing 2D functions as 3D surfaces and contour maps using Python and Matplotlib.\n\n\n\n\n\nJan 26, 2026\n\n\nAnant Kumar\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJan 23, 2026\n\n\nTristan O’Malley\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/matrix-multiplication-benchmarking/index.html",
    "href": "posts/matrix-multiplication-benchmarking/index.html",
    "title": "76x Faster: Benchmarking Matrix Multiplication in C",
    "section": "",
    "text": "Matrix multiplication is the “Hello World” of High-Performance Computing. In this post, I explore how much performance we can squeeze out of a standard \\(C = A \\times B\\) operation on a modern CPU.\nWe tested four implementations on a square matrix of size \\(N = 2048\\):",
    "crumbs": [
      "About",
      "Recent Posts",
      "Posts",
      "76x Faster: Benchmarking Matrix Multiplication in C"
    ]
  },
  {
    "objectID": "posts/matrix-multiplication-benchmarking/index.html#the-benchmark-results",
    "href": "posts/matrix-multiplication-benchmarking/index.html#the-benchmark-results",
    "title": "76x Faster: Benchmarking Matrix Multiplication in C",
    "section": "The Benchmark Results",
    "text": "The Benchmark Results\nThe performance difference was massive. The final optimized version was 76x faster than the naive implementation (estimated).\n\n\n\nImplementation\nExecution Time (s)\nSpeedup\n\n\n\n\nNaive\n~84.0 s\n1.0x\n\n\nLoop Reordered\n~12.5 s\n6.7x\n\n\nSIMD (AVX2)\n~3.8 s\n22.1x\n\n\nTiled + OpenMP + SIMD\n1.10 s\n76.4x",
    "crumbs": [
      "About",
      "Recent Posts",
      "Posts",
      "76x Faster: Benchmarking Matrix Multiplication in C"
    ]
  },
  {
    "objectID": "posts/matrix-multiplication-benchmarking/index.html#the-naive-approach",
    "href": "posts/matrix-multiplication-benchmarking/index.html#the-naive-approach",
    "title": "76x Faster: Benchmarking Matrix Multiplication in C",
    "section": "1. The Naive Approach",
    "text": "1. The Naive Approach\nThe mathematical definition of matrix multiplication is straightforward: \\[C_{ij} = \\sum_k A_{ik} B_{kj}\\]\nIn C, this translates to three nested loops.\n// --- 1. Naive Implementation ---\nvoid matmul_naive(double *A, double *B, double *C, int rowsA, int colsA, int colsB) {\n    int i, j, k;\n    for (i = 0; i &lt; rowsA; ++i) {\n        for (j = 0; j &lt; colsB; ++j) {\n            double sum = 0;\n            for (k = 0; k &lt; colsA; ++k) {\n                sum += A[i * colsA + k] * B[k * colsB + j];\n            }\n            C[i * colsB + j] = sum;\n        }\n    }\n}\nThe Problem: This approach suffers from poor cache locality. As we iterate through \\(B_{kj}\\) (inner loop on k), we are jumping across memory rows. Since C stores arrays in row-major order, this leads to frequent cache misses.",
    "crumbs": [
      "About",
      "Recent Posts",
      "Posts",
      "76x Faster: Benchmarking Matrix Multiplication in C"
    ]
  },
  {
    "objectID": "posts/contour-plots/index.html",
    "href": "posts/contour-plots/index.html",
    "title": "Visualizing Functions with Contour Plots",
    "section": "",
    "text": "Visualizing functions of two variables can provide deep insights into their behavior. In this post, we will explore how to create 3D surface plots and contour plots using Python’s Matplotlib library. We will use the function \\(z =  x^2 + y^2\\) as our example.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nConisder a two dimensional function \\(f(x,y)\\). To visualize the function, its graph can be plotted as follows: For each point \\((x,y)\\) on the \\(xy\\)-plane, evaluate the value of \\(f\\) and assign that value to a variable \\(z\\), so that \\(z=f(x,y)\\). In the 3D space, the graph \\(z=f(x,y)\\) gives a surface. For example, consider the function \\(f(x,y) = x^2+y^2\\). Let’s plot the surface \\[\nz=x^2+y^2\n\\]\n\n\nCode\ndef f(x,y):\n    return x**2+y**2\n\n\n\n\nCode\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# Create gridpoints\nx = np.linspace(-5,5,100)\ny = np.linspace(-5,5,100)\nX,Y = np.meshgrid(x,y)\n\n# Create figure\nfig = plt.figure(figsize=(10,10))\nax = fig.add_subplot(111, projection='3d')\n\n# Plot the surface\nax.plot_surface(X, Y, f(X, Y), cmap='viridis')\n\n# Set labels\nax.set_xlabel('x axis')\nax.set_ylabel('y axis')\nax.set_zlabel('z axis')\nax.set_title('3D plot of z = x^2 + y^2')\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\nA level curve of the function \\(f(x,y)\\) is a curve showing the set of points where the function has a constant value.\nIn the above example, suppose we need the level curve where \\(f(x,y) =10\\). This will be obtained as the intersection of the surface \\(z=x^2 + y^2\\) with the plane \\(z=10\\).\n\n\nCode\nZ= f(X,Y)\n\n# Create a figure and a 3D axis\nfig = plt.figure(figsize=(10, 10))\n\n# 3D plot for the surface\nax = fig.add_subplot(111, projection='3d')\n\n# Plot the surface slightly translucent\nax.plot_surface(X, Y, Z, cmap='viridis', alpha=0.7)\n\n# Plot the contour (level curve) for z = 10 on the surface\nax.contour(X, Y,Z, levels=[10], colors='r', linewidths=2)\n\n# Set labels for 3D plot\nax.set_xlabel('x axis')\nax.set_ylabel('y axis')\nax.set_zlabel('z axis')\nax.set_title('3D plot of z = x^2 + y^2')\n\n# Show the plots\nplt.show()\n\n\n\n\n\n\n\n\n\nIf the level curves are drawn at regular intervals of the \\(z\\) coordinates, we shall obtain many such circles whose centers are located on the \\(z\\) axis and are equal spaced along it.\n\n\nCode\n# Create a figure and a 3D axis\nfig = plt.figure(figsize=(10, 10))\n\n# 3D plot for the surface\nax = fig.add_subplot(111, projection='3d')\n\n# Plot the surface slightly translucent\nax.plot_surface(X, Y, Z, cmap='viridis', alpha=0.7)\n\n# Plot the contour (level curve) for z = 10 on the surface\nax.contour(X, Y,Z, levels=[3*k for k in range(0, 10)], colors='r', linewidths=1)\n\n# Set labels for 3D plot\nax.set_xlabel('x axis')\nax.set_ylabel('y axis')\nax.set_zlabel('z axis')\nax.set_title('3D plot of z = x^2 + y^2')\n\n# Show the plots\nplt.show()\n\n\n\n\n\n\n\n\n\nIf these level curves are projected back on the \\(xy\\) plane, we get the contour plots. In our case, they will be circels. However, as the surface on which the level curves are present is curved, the contours projected on the \\(xy\\) plane will not be equally spaced.\n\n\nCode\n# Create a figure and a 3D axis\nfig = plt.figure(figsize=(10, 10))\n\n# 3D plot for the surface\nax = fig.add_subplot(111, projection='3d')\n\n# Plot the surface slightly translucent\nax.plot_surface(X, Y, Z, cmap='viridis', alpha=0.7)\n\n# Plot the contour (level curve) for various values of z on the surface\nax.contour(X, Y,Z, levels=[3*k for k in range(0, 10)], colors='r', linewidths=1)\n\n# Project the contours  onto the xy-plane at z=0\nax.contour(X, Y, Z, levels=[3*k for k in range(0, 10)], linewidths=1, offset=0)\n\n# Set labels for 3D plot\nax.set_xlabel('x axis')\nax.set_ylabel('y axis')\nax.set_zlabel('z axis')\nax.set_title('3D plot of z = x^2 + y^2')\n\n# Show the plots\nplt.show()\n\n\n\n\n\n\n\n\n\nIf you just see these contours on the \\(xy\\) plane, they still give an idea as to how the function behaves.\n\n\nCode\nfig, ax = plt.subplots(figsize=(10,10))\nCS = ax.contour(X, Y, Z, levels=[3*k for k in range(0, 10)])\nax.clabel(CS, inline=True, fontsize=10)\nax.set_xlabel('x axis')\nax.set_ylabel('y axis')\nax.set_title('Contour plots of z = x^2+y^2')\nax.set_aspect('equal')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nContour plots for Sum of Squared Errors in Linear Regression\n\nFor ease of visualization, let’s consider a 2D dataset which has \\(n\\) datapoints each having two features, say \\(x_1\\), \\(x_2\\). The numerical values of these features for the \\(i\\)-th vector \\(\\mathbf{x}_i\\) are denoted as \\(x_{1i}\\) and \\(x_{2i}\\). The label for \\(\\mathbf{x}_i\\) is \\(y_i\\). The linear regression model is \\[\nf(\\mathbf{w}, \\mathbf{x}) = \\mathbf{w}^T \\mathbf{x} = w_1 x_1 + w_2 x_2\n\\] where \\(\\mathbf{w} = \\begin{bmatrix} w_1 \\\\ w_2 \\end{bmatrix}\\) is the weight vector which needs to be chosen so that the sum of the squared errors (SSE) is minimized. The error for the \\(i\\)-th datapoint is \\[\n\\mathbf{w}^T \\mathbf{x}_i  - y_i = w_1 x_{1i} + w_2 x_{2i}  - y_i\n\\] (I have removed the intercept term as it will make the loss function a three variable function which will be difficult to visualize).\nAs such the SSE is \\[\nL(w_1, w_2) = \\sum_{i=1}^n (w_1x_{1i} + w_2 x_{2i}-y_i)^2\n\\] Using the expansion formula \\[\n(a+b+c)^2 = a^2 +b^2 +c^2 + 2ab +2bc + 2ca\n\\] we get \\[\nL(w_1, w_2) = \\sum_{i=1}^n (w_1^2 x_{1i}^2  + w_2^2  x_{2i}^2 + y_i^2 + 2w_1 w_2 x_{1i} x_{2i}  - 2 w_1 x_{1i} y_i - 2 w_2 x_{2i} y_i)\n\\] As \\(w_1\\), \\(w_2\\) do not depend on the index \\(i\\), the loss function becomes \\[\nL(w_1, w_2) = w_1^2 \\sum_{i=1}^n x_{1i}^2  + w_2^2 \\sum_{i=1}^n x_{2i}^2  + \\sum_{i=1}^n y_i^2 + 2w_1 w_2 \\sum_{i=1}^n x_{1i} x_{2i}  - 2 w_1 \\sum_{i=1}^n x_{1i} y_i - 2 w_2 \\sum_{i=1}^n x_{2i} y_i\n\\] Notice that each of the sums above are constants depending on the dataset. As the SSE is a quadratic function in \\(w_1\\), \\(w_2\\) of the form \\[\nL(w_1, w_2) = a w_1^2 + b w_2^2 + 2h w_1 w_2 + 2g w_1 + 2f w_2 + c \\\\\n\\] where $a = {i=1}^n x{1i}^2 $, \\(b = \\sum_{i=1}^n x_{2i}^2\\), $h = {i=1}^n x{1i} x_{2i} $, $ g = - {i=1}^n x{1i}y_i$, $ f = - {i=1}^n x{2i}y_i$ and \\(c = \\sum_{i=1}^n y_i^2\\).\nThe contour plots are equations of the form \\[\na w_1^2 + b w_2^2 + 2h w_1 w_2 + 2g w_1 + 2f w_2 + c = z\n\\] for some real constant \\(z\\). These equations, in general, represent conic sections. In fact, because of Cauchy-Schwarz inequality, \\(h^2 -ab \\le 0\\), hence the conic section is an ellipse (if \\(h^2 -ab &lt;0\\)) or a parabola (if \\(h^2=ab\\)).\nLet us try to visualize SSE contours with a toy dataset.\n\n\nCode\n# Example dataset\nX_train = np.random.rand(100, 2)   # 100 points between 0 and 1 for two features\ny_train = 3 * X_train[:, 0] + 2 * X_train[:, 1] + np.random.randn(100)  # Linear relation with noise\n\n\n\n\nCode\na = np.sum(X_train[:, 0] ** 2)\nb = np.sum(X_train[:, 1] ** 2)\nh = np.sum(X_train[:, 0] * X_train[:, 1])\ng = -np.sum(X_train[:, 0] * y_train)\nf = -np.sum(X_train[:, 1] * y_train)\nc = np.sum(y_train ** 2)\n\n\n\n\nCode\ndef find_center(a,b,h,g,f,c):\n  xc = (f*h - b*g)/(a*b - h*h)\n  yc = (g*h - a*f)/(a*b - h*h)\n  return np.array([xc,yc])\n\n\n\n\nCode\ndef SSE(w1, w2):\n    return a* w1**2 + b* w2**2 + 2*h*w1*w2 + 2*g*w1 + 2*f*w2 + c\n\n\n\n\nCode\n# Create gridpoints centered about (xc, yc)\n\nif a*b - h*h != 0:\n  xc, yc = find_center(a,b,h,g,f,c)\n  x = np.linspace(xc-1,xc+1,100)\n  y = np.linspace(yc-1,yc+1,100)\n  x,y = np.meshgrid(x,y)\nelse:\n  x = np.linspace(1,4,100)\n  y = np.linspace(1,4,100)\n  x,y = np.meshgrid(x,y)\n\n\nz = SSE(x,y)\n\nfig, ax = plt.subplots(figsize=(10,10))\ncontours = ax.contour(x, y, z)\nax.clabel(contours, inline=True, fontsize=10)\nax.set_xlabel('w1 axis')\nax.set_ylabel('w2 axis')\nax.set_title('Contour plots of SSE')\nax.set_aspect('equal')\nplt.show()",
    "crumbs": [
      "About",
      "Recent Posts",
      "Posts",
      "Visualizing Functions with Contour Plots"
    ]
  }
]